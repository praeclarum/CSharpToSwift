namespace CSharpToSwift;

using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.MSBuild;

class Transpiler
{
    readonly string projectFilePath;
    readonly string swiftPackageName;
    readonly string swiftPackageDir;
    readonly string sourcesDir;
    readonly MSBuildWorkspace workspace = MSBuildWorkspace.Create();
    public Transpiler(string projectFilePath, string outputDir)
    {
        this.projectFilePath = Path.GetFullPath(projectFilePath);
        this.swiftPackageName = Path.GetFileNameWithoutExtension(projectFilePath);
        this.swiftPackageDir = outputDir;
        this.sourcesDir = outputDir;
    }
    static Transpiler()
    {
        Microsoft.Build.Locator.MSBuildLocator.RegisterDefaults();
        var _ = typeof(Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptions);
    }
    readonly Dictionary<string, int> errorCounts = new Dictionary<string, int> ();
    void Error(string message)
    {
        if (!errorCounts.ContainsKey(message)) {
            errorCounts[message] = 0;
            // Console.ForegroundColor = ConsoleColor.Red;
            // Console.WriteLine(message);
            // Console.ResetColor();
        }
        errorCounts[message]++; 
    }
    void Info(string message)
    {
        Console.ForegroundColor = ConsoleColor.Green;
        Console.WriteLine(message);
        Console.ResetColor();
    }
    
    public async Task TranspileAsync()
    {
        Directory.CreateDirectory(sourcesDir);
        var projectFileName = Path.GetFileName(projectFilePath);
        Info($"Loading project {projectFileName}...");
        var project = await workspace.OpenProjectAsync(projectFilePath);
        var projectLoadErrors = workspace.Diagnostics.Where(x => x.Kind == WorkspaceDiagnosticKind.Failure);
        foreach (var d in projectLoadErrors) {
            Error(d.Message);
        }
        if (projectLoadErrors.Any()) {
            Console.WriteLine($"Failed to load project {projectFileName}");
            return;
        }
        Info($"Analyzing project {project.Name}...");
        var compilation = await project.GetCompilationAsync();
        if (compilation is null) {
            Error("Failed to get compilation");
            return;
        }
        var compErrors = compilation.GetDiagnostics().Where(x => x.Severity == DiagnosticSeverity.Error).ToList();
        if (compErrors.Count > 0) {
            foreach (var d in compErrors) {
                Error(d.ToString());
            }
            return;
        }
        
        Info($"Transpiling...");
        var types = new List<(MemberDeclarationSyntax Syntax, SemanticModel Model)>();
        await GetTypeDeclarationsAsync (compilation, types);

        // var outputDir = System.IO.Path.GetDirectoryName(projectFilePath);
        TextWriter NewSwiftWriter(string swiftName) {
            var fileName = $"{swiftName}.swift";
            var filePath = System.IO.Path.Combine(sourcesDir, fileName);
            var w = new System.IO.StreamWriter(filePath);
            w.WriteLine($"// This file was generated from {Path.GetFileName(projectFileName)} by CSharpToSwift version {typeof(Transpiler).Assembly.GetName().Version}");
            return w;
        }
        using (var pw = new StreamWriter(Path.Combine(swiftPackageDir, "Package.swift"))) {
            pw.WriteLine($"// swift-tools-version: 5.6");
            pw.WriteLine();
            pw.WriteLine($"import PackageDescription");
            pw.WriteLine();
            pw.WriteLine($"let package = Package(");
            pw.WriteLine($"    name: \"{swiftPackageName}\",");
            pw.WriteLine($"    products: [");
            pw.WriteLine($"        .library(name: \"{swiftPackageName}\",");
            pw.WriteLine($"                 targets: [\"{swiftPackageName}\"])");
            pw.WriteLine($"    ],");
            pw.WriteLine($"    dependencies: [");
            pw.WriteLine($"    ],");
            pw.WriteLine($"    targets: [");
            pw.WriteLine($"        .target(name: \"{swiftPackageName}\",");
            pw.WriteLine($"                dependencies: []),");
            pw.WriteLine($"    ]");
            pw.WriteLine($")");
        }
        var swift = new StringWriter();
        swift.WriteLine("// This file was generated by CSharpToSwift");
        foreach (var (node, model) in types) {
            var symbol = (INamedTypeSymbol)model.GetDeclaredSymbol(node)!;
            var swiftName = GetSwiftTypeName(symbol);
            switch (node.Kind ()) {
                case SyntaxKind.ClassDeclaration:
                    var c = (ClassDeclarationSyntax)node;
                    using (var cw = NewSwiftWriter(swiftName)) {
                        TranspileClass(swiftName, c, symbol, model, "", cw);
                    }
                    break;
                case SyntaxKind.InterfaceDeclaration:
                    var intf = (InterfaceDeclarationSyntax)node;
                    using (var sw = NewSwiftWriter(swiftName)) {
                        TranspileInterface(swiftName, intf, symbol, model, "", sw);
                    }
                    break;
                case SyntaxKind.StructDeclaration:
                    var s = (StructDeclarationSyntax)node;
                    using (var sw = NewSwiftWriter(swiftName)) {
                        TranspileStruct(swiftName, s, symbol, model, "", sw);
                    }
                    break;
                default:
                    Error($"Unsupported type: {node.Kind()}");
                    break;
            }
        }
        // Show errors sorted by count
        var totalErrors = 0;
        foreach (var kvp in errorCounts.OrderBy(x => x.Value)) {
            var count = kvp.Value;
            totalErrors += count;
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Write($"Error:");
            Console.ResetColor();
            Console.WriteLine($" {kvp.Key} ({count}x)");
        }
        if (totalErrors > 0) {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"{totalErrors} errors");
            Console.ResetColor();
        }
        else {
            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine("OK");
            Console.ResetColor();
        }
    }

    void TranspileClass(string swiftName, ClassDeclarationSyntax node, INamedTypeSymbol symbol, SemanticModel model, string indent, TextWriter w)
    {
        w.Write($"{indent}class {swiftName}");
        var head = " : ";
        if (symbol.BaseType is {} baseType && !(baseType.Name == "Object" && baseType.ContainingNamespace.Name == "System")) {
            var baseSwiftName = GetSwiftTypeName(baseType);
            w.Write($"{head}{baseSwiftName}");
            head = ", ";
        }
        foreach (var i in symbol.Interfaces) {
            var baseSwiftName = GetSwiftTypeName(i);
            w.Write($"{head}{baseSwiftName}");
            head = ", ";
        }
        w.WriteLine($" {{");
        foreach (var member in node.Members) {
            TranspileClassOrStructMember(member, swiftName, node, symbol, model, indent + "    ", w, requireMethodBody: true);
        }
        w.WriteLine($"{indent}}}");
    }

    void TranspileInterface(string swiftName, InterfaceDeclarationSyntax node, INamedTypeSymbol symbol, SemanticModel model, string indent, TextWriter w)
    {
        w.Write($"{indent}protocol {swiftName}");
        var head = " : ";
        foreach (var i in symbol.Interfaces) {
            var baseSwiftName = GetSwiftTypeName(i);
            w.Write($"{head}{baseSwiftName}");
            head = ", ";
        }
        w.WriteLine($" {{");
        foreach (var member in node.Members) {
            TranspileClassOrStructMember(member, swiftName, node, symbol, model, indent + "    ", w, requireMethodBody: false);
        }
        w.WriteLine($"{indent}}}");
    }

    void TranspileStruct(string swiftName, StructDeclarationSyntax node, INamedTypeSymbol symbol, SemanticModel model, string indent, TextWriter w)
    {
        w.Write($"{indent}struct {swiftName}");
        var head = " : ";
        foreach (var i in symbol.Interfaces) {
            var baseSwiftName = GetSwiftTypeName(i);
            w.Write($"{head}{baseSwiftName}");
            head = ", ";
        }
        w.WriteLine($" {{");
        foreach (var member in node.Members) {
            TranspileClassOrStructMember(member, swiftName, node, symbol, model, indent + "    ", w, requireMethodBody: true);
        }
        w.WriteLine($"{indent}}}");
    }

    void TranspileClassOrStructMember(MemberDeclarationSyntax member, string typeName, TypeDeclarationSyntax node, INamedTypeSymbol typeSymbol, SemanticModel model, string indent, TextWriter w, bool requireMethodBody)
    {
        switch (member.Kind ()) {
            case SyntaxKind.ClassDeclaration:
                var classDecl = (ClassDeclarationSyntax)member;
                if (model.GetDeclaredSymbol(classDecl) is INamedTypeSymbol classSymbol) {
                    var classSwiftName = GetSwiftTypeName(classSymbol);
                    TranspileClass(classSwiftName, classDecl, classSymbol, model, indent, w);
                }
                else {
                    Error($"Unable to get symbol for class: {classDecl.Identifier.Text}");
                    w.WriteLine($"{indent}/*{classDecl.ToString().Trim()}*/");
                }
                break;
            case SyntaxKind.ConstructorDeclaration:
                TranspileCtor((ConstructorDeclarationSyntax)member, typeSymbol, model, indent, w, requireMethodBody: requireMethodBody);
                break;
            case SyntaxKind.FieldDeclaration:
                TranspileField((FieldDeclarationSyntax)member, typeSymbol, model, indent, w);
                break;
            case SyntaxKind.MethodDeclaration:
                TranspileMethod((MethodDeclarationSyntax)member, typeSymbol, model, indent, w, requireMethodBody: requireMethodBody);
                break;
            case SyntaxKind.PropertyDeclaration:
                TranspileProperty((PropertyDeclarationSyntax)member, typeSymbol, model, indent, w, requireMethodBody: requireMethodBody);
                break;
            case SyntaxKind.StructDeclaration:
                var structDecl = (StructDeclarationSyntax)member;
                if (model.GetDeclaredSymbol(structDecl) is INamedTypeSymbol structSymbol) {
                    var structSwiftName = GetSwiftTypeName(structSymbol);
                    TranspileStruct(structSwiftName, structDecl, structSymbol, model, indent, w);
                }
                else {
                    Error($"Unable to get symbol for struct: {structDecl.Identifier.Text}");
                    w.WriteLine($"{indent}/*{structDecl.ToString().Trim()}*/");
                }
                break;
            default:
                Error($"Unsupported member: {member.Kind()}");
                w.WriteLine($"    /*{member.Kind()}: {member.ToString().Trim()}*/");
                break;
        }
    }

    void TranspileField(FieldDeclarationSyntax field, INamedTypeSymbol containerTypeSymbol, SemanticModel model, string indent, TextWriter w)
    {
        var docs = GetDocs(field);
        var type = model.GetSymbolInfo(field.Declaration.Type).Symbol;
        
        var ftypeName = GetSwiftTypeName(type);
        var isReadOnly = field.Modifiers.Any(x => x.IsKind(SyntaxKind.ReadOnlyKeyword));
        var isStatic = field.Modifiers.Any(x => x.IsKind(SyntaxKind.StaticKeyword));
        var decl = isReadOnly ? (isStatic ? "static let" : "let") : (isStatic ? "static var" : "var");
        
        foreach (var v in field.Declaration.Variables)
        {
            var fieldSymbol = model.GetDeclaredSymbol(v);
            var acc = GetAccessLevelModifier(fieldSymbol);
            var vn = v.Identifier.ToString();
            var initCode = v.Initializer is not null ? TranspileExpression(v.Initializer.Value, model, $"{indent}    ") : null;
            if (initCode is null && !isReadOnly)
                initCode = GetDefaultValue(type);
            var typeSuffix = "";//TODO: Enable null checking. initCode == "nil" ? "?" : "";
            if (initCode is not null)
                initCode = " = " + initCode;
            if (docs.Length > 0)
                w.WriteLine($"{indent}/// {docs}");
            w.WriteLine($"{indent}{acc}{decl} {vn}: {ftypeName}{typeSuffix}{initCode}");
        }
    }

    void TranspileCtor(ConstructorDeclarationSyntax ctor, INamedTypeSymbol containerTypeSymbol, SemanticModel model, string indent, TextWriter w, bool requireMethodBody)
    {
        var docs = GetDocs(ctor);
        if (docs.Length > 0)
            w.WriteLine($"{indent}/// {docs}");
        var methodSymbol = model.GetDeclaredSymbol(ctor);
        var acc = GetAccessLevelModifier(methodSymbol);
        var isStatic = ctor.Modifiers.Any(x => x.IsKind(SyntaxKind.StaticKeyword));
        var slotType = isStatic ? "static " : "";
        w.Write($"{indent}{acc}{slotType}init(");
        TranspileParams(ctor.ParameterList, model, w);
        if (ctor.Body is null && !requireMethodBody) {
            w.WriteLine($")");
        }
        else {
            w.WriteLine($") {{");
            if (ctor.Body is {} block) {
                TranspileBlock(block, model, $"{indent}    ", w);
            }
            w.WriteLine($"{indent}}}");
        }
    }

    void TranspileMethod(MethodDeclarationSyntax method, INamedTypeSymbol containerTypeSymbol, SemanticModel model, string indent, TextWriter w, bool requireMethodBody)
    {
        var docs = GetDocs(method);
        if (docs.Length > 0)
            w.WriteLine($"{indent}/// {docs}");
        var returnType = model.GetSymbolInfo(method.ReturnType).Symbol;
        var isVoid = IsTypeVoid(returnType);
        var returnTypeCode = isVoid ? "" : $" -> {GetSwiftTypeName(returnType)}";
        var methodSymbol = model.GetDeclaredSymbol(method);
        var acc = GetAccessLevelModifier(methodSymbol);
        var isStatic = method.Modifiers.Any(x => x.IsKind(SyntaxKind.StaticKeyword));
        var isOverride = method.Modifiers.Any(x => x.IsKind(SyntaxKind.OverrideKeyword));
        var isSealed = method.Modifiers.Any(x => x.IsKind(SyntaxKind.SealedKeyword));
        var isAbstract = method.Modifiers.Any(x => x.IsKind(SyntaxKind.AbstractKeyword));
        var isVirtual = method.Modifiers.Any(x => x.IsKind(SyntaxKind.VirtualKeyword));
        if (isAbstract)
        {
            // Warning("Abstract methods are not supported");
        }
        // acc = acc + $"/*{method.Modifiers}*/";
        var slotType = isStatic ? "static " : (isOverride ? "override " : (isAbstract ? "/*abstract*/ " : (isVirtual ? "" : (method.Body is not null ? "final " : ""))));
        w.Write($"{indent}{acc}{slotType}func {method.Identifier.ToString()}(");
        TranspileParams(method.ParameterList, model, w);
        w.Write($"){returnTypeCode}");
        if (method.Body is null && !requireMethodBody) {
            w.WriteLine();
        }
        else {
            w.WriteLine($" {{");
            if (method.Body is {} block) {
                TranspileBlock(block, model, $"{indent}    ", w);
            }
            w.WriteLine($"{indent}}}");
        }
    }

    private void TranspileParams(ParameterListSyntax parameterList, SemanticModel model, TextWriter w)
    {
        var head = "";
        foreach (var p in parameterList.Parameters)
        {
            var pname = p.Identifier.ToString();
            if (p.Type is null) {
                Error($"Parameter has no type: {pname}");
                w.Write($"{head}{pname}: Int/*Error: not type*/");
            }
            else {
                var ptypeSymbol = model.GetSymbolInfo(p.Type).Symbol;
                var isArray = IsTypeArray(ptypeSymbol);
                var ptypeName = GetSwiftTypeName(ptypeSymbol);
                var refMod = isArray ? "inout " : "";
                w.Write($"{head}{pname}: {refMod}{ptypeName}");
            }
            head = ", ";
        }
    }

    void TranspileProperty(PropertyDeclarationSyntax prop, INamedTypeSymbol containerTypeSymbol, SemanticModel model, string indent, TextWriter w, bool requireMethodBody)
    {
        var docs = GetDocs(prop);
        if (docs.Length > 0)
            w.WriteLine($"{indent}/// {docs}");
        var returnType = model.GetSymbolInfo(prop.Type).Symbol;
        string slotType = GetSlotTypeModifier(prop);
        var vn = prop.Identifier.ToString();
        var initCode = prop.Initializer is not null ? TranspileExpression(prop.Initializer.Value, model) : null;
        if (initCode is not null)
            initCode = " = " + initCode;
        w.WriteLine($"{indent}{slotType}var {vn}: {GetSwiftTypeName(returnType)}{initCode} {{");
        if (prop.AccessorList is { } alist)
        {
            foreach (var accessor in alist.Accessors)
            {
                var accLevel = GetAccessLevelModifier(accessor, model);
                w.Write($"{indent}    {accessor.Keyword}");
                if (accessor.Body is null && accessor.ExpressionBody is null && !requireMethodBody) {
                    w.WriteLine();
                }
                else {
                    w.WriteLine($" {{");
                    if (accessor.Body is {} block) {
                        TranspileBlock(block, model, $"{indent}        ", w);
                    }
                    else if (accessor.ExpressionBody is {} ebody) {
                        var eCode = TranspileExpression(ebody.Expression, model, $"{indent}        ");
                        w.WriteLine($"{indent}        {eCode}");
                    }
                    w.WriteLine($"{indent}    }}");
                }
            }
        }
        else if (prop.ExpressionBody is {} ebody) {
            var eCode = TranspileExpression(ebody.Expression, model, $"{indent}    ");
            w.WriteLine($"{indent}    get {{ {eCode} }}");
        }
        else {
            Error($"Property has no accessors: {vn}");
            w.WriteLine($"{indent}    // No accessors");
        }
        w.WriteLine($"{indent}}}");
    }

    string TranspileExpression(ExpressionSyntax value, SemanticModel model, string indent = "")
    {
        switch (value.Kind ()) {
            case SyntaxKind.AddExpression:
                var add = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(add.Left, model)} + {TranspileExpression(add.Right, model)}";
            case SyntaxKind.AddAssignmentExpression:
                var addAssign = (AssignmentExpressionSyntax)value;
                return $"{TranspileExpression(addAssign.Left, model)} += {TranspileExpression(addAssign.Right, model)}";
            case SyntaxKind.AndAssignmentExpression:
                var andAssign = (AssignmentExpressionSyntax)value;
                return $"{TranspileExpression(andAssign.Left, model)} &= {TranspileExpression(andAssign.Right, model)}";
            case SyntaxKind.ArrayCreationExpression:
                return TranspileArrayCreation((ArrayCreationExpressionSyntax)value, model, indent);
            case SyntaxKind.ArrayInitializerExpression:
                var aiElements = string.Join(", ", ((InitializerExpressionSyntax)value).Expressions.Select(x => TranspileExpression(x, model, indent)));
                return $"[{aiElements}]";
            case SyntaxKind.AsExpression:
                var ase = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(ase.Left, model)} as? {TranspileExpression(ase.Right, model)}";
            case SyntaxKind.BaseExpression:
                return "super";
            case SyntaxKind.BitwiseAndExpression:
                var bitAnd = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(bitAnd.Left, model)} & {TranspileExpression(bitAnd.Right, model)}";
            case SyntaxKind.BitwiseOrExpression:
                var bitOr = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(bitOr.Left, model)} | {TranspileExpression(bitOr.Right, model)}";
            case SyntaxKind.BitwiseNotExpression:
                var bitNot = (PrefixUnaryExpressionSyntax)value;
                return $"~{TranspileExpression(bitNot.Operand, model)}";
            case SyntaxKind.CastExpression:
                var cast = (CastExpressionSyntax)value;
                return $"{TranspileExpression(cast.Expression, model)} as {GetSwiftTypeName (cast.Type, model)}";
            case SyntaxKind.CharacterLiteralExpression:
                var charLit = (LiteralExpressionSyntax)value;
                return charLit.Token.Text.Replace('\'', '\"');
            case SyntaxKind.CoalesceExpression:
                var coalesce = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(coalesce.Left, model)} ?? {TranspileExpression(coalesce.Right, model)}";
            case SyntaxKind.ConditionalAccessExpression:
                var ca = (ConditionalAccessExpressionSyntax)value;
                return $"{TranspileExpression(ca.Expression, model)}?{TranspileExpression(ca.WhenNotNull, model)}";
            case SyntaxKind.ConditionalExpression:
                var cond = (ConditionalExpressionSyntax)value;
                return $"{TranspileExpression(cond.Condition, model)} ? {TranspileExpression(cond.WhenTrue, model)} : {TranspileExpression(cond.WhenFalse, model)}";
            case SyntaxKind.DivideExpression:
                var div = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(div.Left, model)} / {TranspileExpression(div.Right, model)}";
            case SyntaxKind.DefaultExpression:
                var def = (DefaultExpressionSyntax)value;
                return GetDefaultValue(model.GetTypeInfo(def.Type).Type);
            case SyntaxKind.DivideAssignmentExpression:
                var divAssign = (AssignmentExpressionSyntax)value;
                return $"{TranspileExpression(divAssign.Left, model)} /= {TranspileExpression(divAssign.Right, model)}";
            case SyntaxKind.ElementAccessExpression:
                var ea = (ElementAccessExpressionSyntax)value;
                var eaArgs = TranspileElementArguments(ea.ArgumentList, model, indent);
                return $"{TranspileExpression(ea.Expression, model)}[{eaArgs}]";
            case SyntaxKind.ElementBindingExpression:
                var eb = (ElementBindingExpressionSyntax)value;
                var ebArgs = TranspileElementArguments(eb.ArgumentList, model, indent);
                return $"[{ebArgs}]";
            case SyntaxKind.EqualsExpression:
                var eq = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(eq.Left, model)} == {TranspileExpression(eq.Right, model)}";
            case SyntaxKind.ExclusiveOrExpression:
                var xor = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(xor.Left, model)} ^ {TranspileExpression(xor.Right, model)}";
            case SyntaxKind.FalseLiteralExpression:
                return "false";
            case SyntaxKind.GreaterThanExpression:
                var gt = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(gt.Left, model)} > {TranspileExpression(gt.Right, model)}";
            case SyntaxKind.GreaterThanOrEqualExpression:
                var gte = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(gte.Left, model)} >= {TranspileExpression(gte.Right, model)}";
            case SyntaxKind.IdentifierName:
                var id = (IdentifierNameSyntax)value;
                return id.Identifier.ToString();
            case SyntaxKind.ImplicitArrayCreationExpression:
                var iac = (ImplicitArrayCreationExpressionSyntax)value;
                var iacArgs = string.Join(", ", iac.Initializer.Expressions.Select(e => TranspileExpression(e, model, indent)));
                return $"[{iacArgs}]";
            case SyntaxKind.InvocationExpression:
                var inv = (InvocationExpressionSyntax)value;
                return TranspileInvocation(TranspileExpression(inv.Expression, model), inv, inv.ArgumentList, model, indent);
            case SyntaxKind.IsExpression:
                var ise = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(ise.Left, model)} is {TranspileExpression(ise.Right, model)}";
            case SyntaxKind.IsPatternExpression:
                return TranspileIsPattern((IsPatternExpressionSyntax)value, model, indent);
            case SyntaxKind.LeftShiftExpression:
                var lshift = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(lshift.Left, model)} << {TranspileExpression(lshift.Right, model)}";
            case SyntaxKind.LeftShiftAssignmentExpression:
                var lshiftAssign = (AssignmentExpressionSyntax)value;
                return $"{TranspileExpression(lshiftAssign.Left, model)} <<= {TranspileExpression(lshiftAssign.Right, model)}";
            case SyntaxKind.LessThanExpression:
                var lt = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(lt.Left, model)} < {TranspileExpression(lt.Right, model)}";
            case SyntaxKind.LessThanOrEqualExpression:
                var lte = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(lte.Left, model)} <= {TranspileExpression(lte.Right, model)}";
            case SyntaxKind.LogicalAndExpression:
                var and = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(and.Left, model)} && {TranspileExpression(and.Right, model)}";
            case SyntaxKind.LogicalNotExpression:
                var not = (PrefixUnaryExpressionSyntax)value;
                return $"!{TranspileExpression(not.Operand, model)}";
            case SyntaxKind.LogicalOrExpression:
                var or = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(or.Left, model)} || {TranspileExpression(or.Right, model)}";
            case SyntaxKind.MemberBindingExpression:
                var mbe = (MemberBindingExpressionSyntax)value;
                return $".{TranspileExpression(mbe.Name, model)}";
            case SyntaxKind.ModuloExpression:
                var mod = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(mod.Left, model)} % {TranspileExpression(mod.Right, model)}";
            case SyntaxKind.MultiplyExpression:
                var mul = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(mul.Left, model)} * {TranspileExpression(mul.Right, model)}";
            case SyntaxKind.MultiplyAssignmentExpression:
                var mulAssign = (AssignmentExpressionSyntax)value;
                return $"{TranspileExpression(mulAssign.Left, model)} *= {TranspileExpression(mulAssign.Right, model)}";
            case SyntaxKind.NotEqualsExpression:
                var neq = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(neq.Left, model)} != {TranspileExpression(neq.Right, model)}";
            case SyntaxKind.NullLiteralExpression:
                return "nil";
            case SyntaxKind.NumericLiteralExpression:
                var nlit = (LiteralExpressionSyntax)value;
                {
                    var ntext = nlit.Token.Text;
                    if (ntext[0] == '.')
                        ntext = "0" + ntext;
                    if (ntext[^1] == 'f')
                        ntext = ntext.Substring(0, ntext.Length - 1);
                    if (ntext.EndsWith("ul", StringComparison.InvariantCultureIgnoreCase))
                        ntext = $"UInt64({ntext.Substring(0, ntext.Length - 2)})";
                    return ntext;
                }
            case SyntaxKind.ObjectCreationExpression:
                return TranspileObjectCreationExpression((ObjectCreationExpressionSyntax)value, model, indent);
            case SyntaxKind.OrAssignmentExpression:
                var orAssign = (AssignmentExpressionSyntax)value;
                return $"{TranspileExpression(orAssign.Left, model)} |= {TranspileExpression(orAssign.Right, model)}";
            case SyntaxKind.ParenthesizedExpression:
                var paren = (ParenthesizedExpressionSyntax)value;
                return $"({TranspileExpression(paren.Expression, model)})";
            case SyntaxKind.ParenthesizedLambdaExpression:
                var parenLambda = (ParenthesizedLambdaExpressionSyntax)value;
                return TranspileLambdaExpression(parenLambda.ParameterList.Parameters, parenLambda, model, indent);
            case SyntaxKind.PostDecrementExpression:
                var postDec = (PostfixUnaryExpressionSyntax)value;
                return $"{TranspileExpression(postDec.Operand, model)} -= 1";
            case SyntaxKind.PostIncrementExpression:
                var postInc = (PostfixUnaryExpressionSyntax)value;
                return $"{TranspileExpression(postInc.Operand, model)} += 1";
            case SyntaxKind.PredefinedType:
                return GetSwiftTypeName(value, model);
            case SyntaxKind.PreDecrementExpression:
                var preDec = (PrefixUnaryExpressionSyntax)value;
                return $"{TranspileExpression(preDec.Operand, model)} -= 1";
            case SyntaxKind.PreIncrementExpression:
                var preInc = (PrefixUnaryExpressionSyntax)value;
                return $"{TranspileExpression(preInc.Operand, model)} += 1";
            case SyntaxKind.RangeExpression:
                var range = (RangeExpressionSyntax)value;
                var rangeStart = range.LeftOperand is not null ? TranspileExpression(range.LeftOperand, model) : null;
                var rangeEnd = range.RightOperand is not null ? TranspileExpression(range.RightOperand, model) : null;
                if (rangeEnd is not null)
                    return $"{rangeStart}..<{rangeEnd}";
                else
                    return $"{rangeStart}...";
            case SyntaxKind.RightShiftExpression:
                var rshift = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(rshift.Left, model)} >> {TranspileExpression(rshift.Right, model)}";
            case SyntaxKind.RightShiftAssignmentExpression:
                var rshiftAssign = (AssignmentExpressionSyntax)value;
                return $"{TranspileExpression(rshiftAssign.Left, model)} >>= {TranspileExpression(rshiftAssign.Right, model)}";
            case SyntaxKind.SimpleAssignmentExpression:
                var sae = (AssignmentExpressionSyntax)value;
                return $"{TranspileExpression(sae.Left, model)} = {TranspileExpression(sae.Right, model)}";
            case SyntaxKind.SimpleLambdaExpression:
                var simpleLambda = (SimpleLambdaExpressionSyntax)value;
                return TranspileLambdaExpression(new[]{simpleLambda.Parameter}, simpleLambda, model, indent);
            case SyntaxKind.SimpleMemberAccessExpression:
                var sma = (MemberAccessExpressionSyntax)value;
                return $"{TranspileExpression(sma.Expression, model)}.{sma.Name.ToString()}";
            case SyntaxKind.StringLiteralExpression:
                var slit = (LiteralExpressionSyntax)value;
                {
                    var stext = slit.Token.Text;
                    if (stext.Length > 0 && stext[0] == '@') {
                        stext = "\"\"\"\n" + slit.Token.ValueText + "\n\"\"\"";
                    }
                    return stext;
                }
            case SyntaxKind.SubtractAssignmentExpression:
                var subAssign = (AssignmentExpressionSyntax)value;
                return $"{TranspileExpression(subAssign.Left, model)} -= {TranspileExpression(subAssign.Right, model)}";
            case SyntaxKind.SubtractExpression:
                var sub = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(sub.Left, model)} - {TranspileExpression(sub.Right, model)}";
            case SyntaxKind.ThisExpression:
                return "self";
            case SyntaxKind.TrueLiteralExpression:
                return "true";
            case SyntaxKind.UnaryMinusExpression:
                var ume = (PrefixUnaryExpressionSyntax)value;
                return $"-{TranspileExpression(ume.Operand, model)}";
            default:
                Error($"Unsupported expression: {value.Kind()}");
                return $"nil/*{value.Kind()}: {value.ToString().Trim()}*/";
        }
    }

    string TranspileIsPattern(IsPatternExpressionSyntax value, SemanticModel model, string indent)
    {
        var exprCode = TranspileExpression(value.Expression, model, indent);
        switch (value.Pattern.Kind ()) {
            case SyntaxKind.DeclarationPattern:
                var dp = (DeclarationPatternSyntax)value.Pattern;
                var dpTypeName = GetSwiftTypeName(dp.Type, model);
                if (dp.Designation is SingleVariableDesignationSyntax svds) {
                    return $"let {svds.Identifier} = {exprCode} as? {dpTypeName}";
                }
                else {
                    Error($"Unsupported declaration pattern: {dp.Designation.ToString()}");
                    return $"{exprCode}/* is {dp.Designation.ToString()}*/";
                }
            case SyntaxKind.ConstantPattern:
                var cp = (ConstantPatternSyntax)value.Pattern;
                switch (cp.Expression.Kind()) {
                    case SyntaxKind.TrueLiteralExpression:
                        return $"{exprCode}";
                    case SyntaxKind.FalseLiteralExpression:
                        return $"!{exprCode}";
                    case SyntaxKind.NullLiteralExpression:
                        return $"{exprCode} == nil";
                    default:
                        return $"{exprCode} == {TranspileExpression(cp.Expression, model)}";
                }
            default:
                Error($"Unsupported pattern: {value.Pattern.Kind()}");
                return $"{exprCode}/*{value.Pattern.Kind()}: {value.Pattern.ToString().Trim()}*/";
        }
    }

    private string TranspileArrayCreation(ArrayCreationExpressionSyntax array, SemanticModel model, string indent)
    {
        var etypeSymbol = model.GetTypeInfo(array.Type.ElementType).Type;
        if (array.Type.RankSpecifiers.Count == 1 && array.Type.RankSpecifiers[0].Sizes is {Count:1} sizes) {
            var lengthExpr = sizes[0];
            var length = TryEvaluateConstantIntExpression(lengthExpr, model, 0);
            if (array.Initializer is {} init) {
                var sb = new System.Text.StringBuilder();
                sb.Append("[");
                var head = "";
                var num = 0;
                foreach (var e in init.Expressions) {
                    sb.Append(head);
                    sb.Append(TranspileExpression(e, model, indent));
                    head = ", ";
                    num++;
                }
                if (num < length) {
                    var valueCode = GetDefaultValue(etypeSymbol);
                    for (var i = num; i < length; i++) {
                        sb.Append(head);
                        sb.Append(valueCode);
                        head = ", ";
                    }
                }
                sb.Append("]");
                return sb.ToString();
            }
            else  {
                var valueCode = GetDefaultValue(etypeSymbol);
                var lengthCode = TranspileExpression(lengthExpr, model);
                return $"Array(repeating: {valueCode}, count: {lengthCode})";
            }
        }
        else {
            Error($"Unsupported array creation: {array.ToString().Trim()}");
            return $"[]/*{array.ToString().Trim()}*/";
        }
    }

    string TranspileElementArguments(BracketedArgumentListSyntax argList, SemanticModel model, string indent)
    {
        return string.Join(", ", argList.Arguments.Select(x => TranspileExpression(x.Expression, model, indent)));
    }

    string TranspileLambdaExpression(IEnumerable<ParameterSyntax> parameters, LambdaExpressionSyntax lambda, SemanticModel model, string indent)
    {
        var parametersCode = string.Join(", ", parameters.Select(x => x.Identifier.ToString()));
        var sb = new System.Text.StringBuilder();
        sb.Append($"{{ {parametersCode} in");
        if (lambda.ExpressionBody is {} expr) {
            var exprCode = TranspileExpression(expr, model);
            sb.Append($" {exprCode} }}");
        }
        else if (lambda.Block is {} block) {
            using var sw = new StringWriter();
            TranspileBlock(block, model, indent, sw);
            var blockCode = sw.ToString();
            sb.Append($"\n{blockCode}{indent}}}");
        }
        else {
            Error($"Unsupported lambda expression: {lambda.ToString().Trim()}");
            sb.Append($" nil/*{lambda.ToString().Trim()}*/ }}");
        }
        return sb.ToString();
    }

    string TranspileObjectCreationExpression(ObjectCreationExpressionSyntax oc, SemanticModel model, string indent)
    {
        if (model.GetSymbolInfo(oc.Type).Symbol is ITypeSymbol ocTypeSymbol)
        {
            var ocInit = oc.Initializer;
            if (ocTypeSymbol.Name == "Dictionary" && ocTypeSymbol.ContainingNamespace.ToString() == "System.Collections.Generic") {
                var sb = new System.Text.StringBuilder();
                sb.Append("[");
                if (ocInit is not null && ocInit.Expressions.Count > 0)
                {
                    var head = "";
                    foreach (var kv in ocInit.Expressions)
                    {
                        sb.Append(head);
                        if (kv is InitializerExpressionSyntax ie && ie.Expressions.Count == 2) {
                            sb.Append($"{TranspileExpression(ie.Expressions[0], model)}: {TranspileExpression(ie.Expressions[1], model)}");
                        }
                        else {
                            Error($"Unsupported dictionary initializer: {kv.Kind()}");
                            sb.Append($"nil/*{kv.ToString().Trim()}*/");
                        }
                        head = ", ";
                    }
                }
                sb.Append("]");
                return sb.ToString();
            }
            else {
                var ocName = GetSwiftTypeName(ocTypeSymbol);
                var ocCode = oc.ArgumentList != null ? TranspileInvocation(ocName, oc, oc.ArgumentList, model, indent) : $"{ocName}()";
                if (ocInit is not null && ocInit.Expressions.Count > 0)
                {
                    var kw = ocTypeSymbol.IsReferenceType ? "let" : "var";
                    var inits = ocInit.Expressions.Select(x => $"x.{TranspileExpression(x, model)}");
                    var initsCode = string.Join("; ", inits);
                    ocCode = $"{{ {kw} x = {ocCode}; {initsCode} }}()";
                }
                return ocCode;
            }
        }
        else
        {
            Error($"Unable to determine type of object creation expression: {oc.Type.ToString()}");
            return $"nil/*no type symbol: {oc.Type.ToString().Trim()}*/";
        }
    }

    string TranspileInvocation(string exprCode, SyntaxNode invokeNode, ArgumentListSyntax argList, SemanticModel model, string indent)
    {
        if (exprCode == "nameof" && argList.Arguments.Count == 1)
            return NameOf(argList.Arguments[0].Expression);
        var method = model.GetSymbolInfo(invokeNode).Symbol as IMethodSymbol;
        if (method == null) {
            Error($"Method resolution failed: {invokeNode}");
            var fargs = argList.Arguments.Select(a => TranspileExpression(a.Expression, model)).ToArray();
            return $"{exprCode}({string.Join(", ", fargs)})";
        }
        var parameters = method.Parameters;
        if (parameters.Length == 0) {
            return $"{exprCode}()";
        }
        var args = argList.Arguments;
        var nparams = parameters.Length;
        var nargs = args.Count;
        var sb = new System.Text.StringBuilder();
        var aindent = $"{indent}    ";
        sb.Append(exprCode);
        sb.Append("(");
        for (var i = 0; i < nparams; i++) {
            var paramName = parameters[i].Name;
            if (i > 0)
                sb.Append(", ");
            sb.Append(paramName);
            sb.Append(": ");
            if (i < nargs) {
                var arg = args[i];
                sb.Append(TranspileExpression(arg.Expression, model, aindent));
            } else {
                Error("Missing argument value");
                sb.Append("nil/*missing*/");
            }
        }
        if (nargs > nparams) {
            Error("Too many arguments");
            for (var i = nparams; i < nargs; i++) {
                var arg = args[i];
                sb.Append(", ");
                sb.Append(TranspileExpression(arg.Expression, model, aindent));
                sb.Append("/*extra*/");
            }
        }
        sb.Append(")");
        return sb.ToString();
    }

    string NameOf(ExpressionSyntax value)
    {
        var name = value switch {
            IdentifierNameSyntax id => id.Identifier.ToString(),
            MemberAccessExpressionSyntax mae => mae.Name.ToString(),
            _ => value.ToString()
        };
        return $"\"{name}\"";
    }

    void TranspileBlock(BlockSyntax block, SemanticModel model, string indent, TextWriter w)
    {
        foreach (var stmt in block.Statements)
        {
            TranspileStatement(stmt, model, indent, w);
        }
    }

    void TranspileStatement(StatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        switch (stmt.Kind()) {
            case SyntaxKind.Block:
                TranspileBlock((BlockSyntax)stmt, model, indent, w);
                break;
            case SyntaxKind.BreakStatement:
                w.WriteLine($"{indent}break");
                break;
            case SyntaxKind.ContinueStatement:
                w.WriteLine($"{indent}continue");
                break;
            case SyntaxKind.ExpressionStatement:
                TranspileExpressionStatement((ExpressionStatementSyntax)stmt, model, indent, w);
                break;
            case SyntaxKind.ForStatement:
                TranspileForStatement((ForStatementSyntax)stmt, model, indent, w);
                break;
            case SyntaxKind.ForEachStatement:
                TranspileForEachStatement((ForEachStatementSyntax)stmt, model, indent, w);
                break;
            case SyntaxKind.IfStatement:
                TranspileIfStatement((IfStatementSyntax)stmt, model, indent, w);
                break;
            case SyntaxKind.LocalDeclarationStatement:
                var ld = (LocalDeclarationStatementSyntax)stmt;
                TranspileVariableDeclaration(ld.Declaration, model, indent, w);
                break;
            case SyntaxKind.ReturnStatement:
                TranspileReturnStatement((ReturnStatementSyntax)stmt, model, indent, w);
                break;
            case SyntaxKind.SwitchStatement:
                TranspileSwitchStatement((SwitchStatementSyntax)stmt, model, indent, w);
                break;
            case SyntaxKind.ThrowStatement:
                var thrw = (ThrowStatementSyntax)stmt;
                if (thrw.Expression is {} expr) {
                    w.WriteLine($"{indent}throw {TranspileExpression(thrw.Expression, model)}");
                }
                else {
                    w.WriteLine($"{indent}throw");
                }
                break;
            case SyntaxKind.TryStatement:
                TranspileTryStatement((TryStatementSyntax)stmt, model, indent, w);
                break;
            case SyntaxKind.UsingStatement:
                TranspileUsingStatement((UsingStatementSyntax)stmt, model, indent, w);
                break;
            case SyntaxKind.WhileStatement:
                TranspileWhileStatement((WhileStatementSyntax)stmt, model, indent, w);
                break;
            default:
                Error($"Unsupported statement: {stmt.Kind()}");
                w.WriteLine($"{indent}/*{stmt.Kind()}: {stmt.ToString().Trim()}*/");
                break;
        }
    }

    void TranspileExpressionStatement(ExpressionStatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        var expr = TranspileExpression(stmt.Expression, model);
        w.WriteLine($"{indent}{expr}");
    }

    void TranspileForStatement(ForStatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        if (stmt.Declaration is {} decl) {
            TranspileVariableDeclaration(decl, model, indent, w);
        }
        var cond = stmt.Condition is not null ? TranspileExpression(stmt.Condition, model) : "true";
        w.WriteLine($"{indent}while {cond} {{");
        TranspileStatement(stmt.Statement, model, indent + "    ", w);
        foreach (var incr in stmt.Incrementors) {
            var expr = TranspileExpression(incr, model);
            w.WriteLine($"{indent}    {expr}");
        }
        w.WriteLine($"{indent}}}");
    }

    void TranspileForEachStatement(ForEachStatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        var expr = stmt.Expression;
        var ident = stmt.Identifier;
        var exprCode = TranspileExpression(expr, model);
        w.WriteLine($"{indent}for {ident.ValueText} in {exprCode} {{");
        TranspileStatement(stmt.Statement, model, indent + "    ", w);
        w.WriteLine($"{indent}}}");
    }

    void TranspileIfStatement(IfStatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        var cond = TranspileExpression(stmt.Condition, model);
        w.WriteLine($"{indent}if {cond} {{");
        TranspileStatement(stmt.Statement, model, indent + "    ", w);
        if (stmt.Else is { } elseClause)
        {
            w.WriteLine($"{indent}}} else {{");
            TranspileStatement(elseClause.Statement, model, indent + "    ", w);
        }
        w.WriteLine($"{indent}}}");
    }

    void TranspileReturnStatement(ReturnStatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        var expr = stmt.Expression;
        if (expr is null)
            w.WriteLine($"{indent}return");
        else
            w.WriteLine($"{indent}return {TranspileExpression(expr, model)}");
    }

    void TranspileSwitchStatement(SwitchStatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        var expr = stmt.Expression;
        w.WriteLine($"{indent}switch {TranspileExpression(expr, model)} {{");
        foreach (var s in stmt.Sections)
        {
            var caseLabels = s.Labels.Where(x => !x.IsKind(SyntaxKind.DefaultSwitchLabel)).ToArray();
            var defLabel = s.Labels.FirstOrDefault(x => x.IsKind(SyntaxKind.DefaultSwitchLabel));
            if (caseLabels.Length > 0) {
                var labels = string.Join(", ", s.Labels.Select(x => {
                    if (x.IsKind(SyntaxKind.DefaultSwitchLabel)) {
                        return "default";
                    } else if (x.IsKind(SyntaxKind.CaseSwitchLabel)) {
                        return TranspileExpression(((CaseSwitchLabelSyntax)x).Value, model, indent);
                    } else {
                        Error($"Unsupported switch label: {x}");
                        return x.ToString();
                    }
                }));
                w.WriteLine($"{indent}case {labels}:");
                foreach (var cstmt in s.Statements) {
                    TranspileStatement(cstmt, model, indent + "    ", w);
                }
            }
            if (defLabel is not null) {
                w.WriteLine($"{indent}default:");
                foreach (var cstmt in s.Statements) {
                    TranspileStatement(cstmt, model, indent + "    ", w);
                }
            }
        }
        w.WriteLine($"{indent}}}");
    }

    void TranspileTryStatement(TryStatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        var block = stmt.Block;
        var catches = stmt.Catches;
        if (catches.Count > 0) {
            w.WriteLine($"{indent}do {{");
            if (stmt.Finally is { } fin) {
                w.WriteLine($"{indent}    defer {{");
                TranspileBlock(fin.Block, model, indent + "        ", w);
                w.WriteLine($"{indent}    }}");
            }
            TranspileBlock(block, model, indent + "    ", w);
            foreach (var catchClause in catches) {
                w.Write($"{indent}}} catch ");
                if (catchClause.Declaration is { } decl) {
                    w.Write (GetSwiftTypeName(decl.Type, model));
                }                
                if (catchClause.Filter is { } filter) {
                    var cond = TranspileExpression(filter.FilterExpression, model);
                    w.WriteLine($"where {cond}");
                }
                w.WriteLine($" {{");
                TranspileBlock(catchClause.Block, model, indent + "    ", w);
                w.WriteLine($"{indent}}}");
            }
        }
        else {
            w.WriteLine($"{indent}{{");
            if (stmt.Finally is { } fin) {
                w.WriteLine($"{indent}    defer {{");
                TranspileBlock(fin.Block, model, indent + "        ", w);
                w.WriteLine($"{indent}    }}");
            }
            TranspileBlock(block, model, indent + "    ", w);
            w.WriteLine($"{indent}}}");
        }
    }

    void TranspileUsingStatement(UsingStatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        w.WriteLine($"{indent}{{");
        if (stmt.Expression is {} expr) {
            var exprCode = TranspileExpression(expr, model);
            w.WriteLine($"{indent}    let using_ = {exprCode}");
        }
        else if (stmt.Declaration is {} decl) {
            TranspileVariableDeclaration(decl, model, indent + "    ", w);
        }
        else {
            Error($"Unsupported using statement");
        }
        w.WriteLine($"{indent}    defer {{");
        if (stmt.Expression is not null) {
            w.WriteLine($"{indent}        using_.Dispose()");
        }
        else if (stmt.Declaration is not null) {
            foreach (var v in stmt.Declaration.Variables) {
                var name = v.Identifier.ValueText;
                w.WriteLine($"{indent}        {name}.Dispose()");
            }
        }
        w.WriteLine($"{indent}    }}");
        TranspileStatement(stmt.Statement, model, indent + "    ", w);
        w.WriteLine($"{indent}}}");
    }

    void TranspileVariableDeclaration(VariableDeclarationSyntax decl, SemanticModel model, string indent, TextWriter w)
    {
        var declType = model.GetTypeInfo(decl.Type).Type;
        var declTypeName = GetSwiftTypeName(declType);
        foreach (var v in decl.Variables)
        {
            var vn = v.Identifier.ToString();
            var initCode = v.Initializer is not null ? TranspileExpression(v.Initializer.Value, model) : GetDefaultValue(declType);
            w.WriteLine($"{indent}var {vn}: {declTypeName} = {initCode}");
        }
    }

    void TranspileWhileStatement(WhileStatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        var cond = TranspileExpression(stmt.Condition, model);
        w.WriteLine($"{indent}while {cond} {{");
        TranspileStatement(stmt.Statement, model, indent + "    ", w);
        w.WriteLine($"{indent}}}");
    }

    static string GetDocs(CSharpSyntaxNode field)
    {
        var lines =
            field.GetLeadingTrivia()
            .Where(x => x.IsKind(SyntaxKind.MultiLineDocumentationCommentTrivia) || x.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia))
            .SelectMany(x => x.ToFullString().Split('\n'))
            .Select(x =>
                x
                .Replace("<summary>", "")
                .Replace("</summary>", "")
                .Replace("<b>", "**")
                .Replace("</b>", "**")
                .Replace("///", "")
                .Replace("\t", " ")
                .Trim())
            .Where(x => x.Length > 0);
        return string.Join(" ", lines);
    }

    static string GetSlotTypeModifier(MemberDeclarationSyntax member)
    {
        var isStatic = member.Modifiers.Any(x => x.IsKind(SyntaxKind.StaticKeyword));
        var isOverride = member.Modifiers.Any(x => x.IsKind(SyntaxKind.OverrideKeyword));
        var isSealed = member.Modifiers.Any(x => x.IsKind(SyntaxKind.SealedKeyword));
        var isAbstract = member.Modifiers.Any(x => x.IsKind(SyntaxKind.AbstractKeyword));
        var isVirtual = member.Modifiers.Any(x => x.IsKind(SyntaxKind.VirtualKeyword));
        var slotType = isStatic ? "static " : (isOverride ? "override " : (isAbstract ? "open " : ""));
        return slotType;
    }

    static string GetAccessLevelModifier(CSharpSyntaxNode node, SemanticModel model)
    {
        var memberSymbol = model.GetSymbolInfo(node).Symbol;
        return GetAccessLevelModifier(memberSymbol);
    }

    static string GetAccessLevelModifier(ISymbol? memberSymbol)
    {
        // access-level-modifier: private | fileprivate | internal | public | open
        if (memberSymbol is null)
            return "";
        return memberSymbol.DeclaredAccessibility switch
        {
            Accessibility.Private => "",
            Accessibility.Protected => "",
            Accessibility.Internal => "",
            Accessibility.Public => "",
            _ => "",
        };
    }

    string GetSwiftTypeName(CSharpSyntaxNode type, SemanticModel model)
    {
        var typeSymbol = model.GetSymbolInfo(type).Symbol;
        return GetSwiftTypeName(typeSymbol);
    }

    string GetSwiftTypeName(ISymbol? s)
    {
        if (s == null) {
            Error($"No symbol type provided");
            return "AnyObject/*no symbol*/";
        }
        else if (s is IArrayTypeSymbol ats) {
            return $"[{GetSwiftTypeName(ats.ElementType)}]";
        }
        else if (s is INamedTypeSymbol nts) {
            var name = nts.Name;
            switch (name) {
                case nameof(System.Boolean):
                    return "Bool";
                case nameof(System.Byte):
                    return "UInt8";
                case nameof(System.Char):
                    return "Character";
                case nameof(System.Int32):
                    return "Int";
                case nameof(System.IntPtr):
                    return "Int";
                case nameof(System.Object):
                    return "AnyObject";
                case nameof(System.Single):
                    return "Float";
                default:
                    if (string.IsNullOrEmpty(name)) {
                        Error($"No name for symbol: {s.GetType()}");
                        return "AnyObject/*no name*/";
                    }
                    else if (name == "Nullable" && s.ContainingNamespace.Name == "System") {
                        return GetSwiftTypeName(nts.TypeArguments.First()) + "?";
                    }
                    return name;
            }
        }
        else if (s is ITypeParameterSymbol tps) {
            return tps.Name;
        }
        else {
            Error($"Unsupported type symbol: {s.GetType()}");
            return $"AnyObject/*{s}*/";
        }
    }

    bool IsTypeVoid(ISymbol? typeSymbol)
    {
        return typeSymbol is null || (typeSymbol.Name == "Void" && typeSymbol.ContainingNamespace.Name == "System");
    }

    static bool IsTypeArray(ISymbol? typeSymbol)
    {
        return typeSymbol is IArrayTypeSymbol;
    }

    int TryEvaluateConstantIntExpression(ExpressionSyntax expr, SemanticModel model, int defaultInt)
    {
        if (expr is LiteralExpressionSyntax lit && lit.IsKind(SyntaxKind.NumericLiteralExpression)) {
            return int.Parse(lit.Token.ValueText);
        }
        return defaultInt;
    }

    string GetDefaultValue(ISymbol? type)
    {
        if (type == null) {
            return "nil";
        }
        switch (type.Kind) {
            case SymbolKind.ArrayType:
                return "[]";
            case SymbolKind.PointerType:
                return "nil";
            case SymbolKind.DynamicType:
                return "nil";
            case SymbolKind.TypeParameter:
                return "nil";
            case SymbolKind.ErrorType:
                return "nil";
            case SymbolKind.NamedType:
                var ntype = (INamedTypeSymbol)type;
                switch (type.Name) {
                    case nameof(System.Boolean):
                        return "false";
                    case nameof(System.Byte):
                        return "0";
                    case nameof(System.Char):
                        return "\"\\0\"";
                    case nameof(System.Double):
                        return "0.0";
                    case nameof(System.Single):
                        return "0.0";
                    case nameof(System.Int16):
                        return "0";
                    case nameof(System.Int32):
                        return "0";
                    case nameof(System.Int64):
                        return "0";
                    case nameof(System.IntPtr):
                        return "0";
                    case nameof(System.UInt16):
                        return "0";
                    case nameof(System.UInt32):
                        return "0";
                    case nameof(System.UInt64):
                        return "0";
                    case nameof(System.UIntPtr):
                        return "0";
                    default:
                        if (ntype.IsReferenceType) {
                            return "nil";
                        }
                        else if (ntype.Name == "Nullable" && ntype.ContainingNamespace.Name == "System") {
                            return "nil";
                        }
                        else if (ntype.Name == "Enum" && ntype.ContainingNamespace.Name == "System") {
                            return "0";
                        }
                        else if (ntype.InstanceConstructors.FirstOrDefault(x => x.Parameters.Length == 0) is IMethodSymbol defaultCtor) {
                            return $"{GetSwiftTypeName(type)}()";
                        }
                        else {
                            Error($"Unsupported default value for named type: {type.Name}");
                            return $"0/*NT:{type.Name}*/";
                        }
                }
            default:
                Error($"Unsupported default value for type {type.Kind}");
                return $"nil/*T:{type.Kind}*/";
        }
    }

    async Task GetTypeDeclarationsAsync(Compilation compilation, List<(MemberDeclarationSyntax Syntax, SemanticModel Symbol)> types)
    {
        foreach (var s in compilation.SyntaxTrees.OfType<CSharpSyntaxTree>()) {
            // Info($"Transpiling {s.FilePath}...");
            var m = compilation.GetSemanticModel(s);
            GetTypeDeclarations(await s.GetRootAsync().ConfigureAwait(false), m, compilation, types);
        }
    }

    void GetTypeDeclarations(CSharpSyntaxNode node, SemanticModel model, Compilation compilation, List<(MemberDeclarationSyntax Syntax, SemanticModel Symbol)> types)
    {
        switch (node.Kind ()) {
            case SyntaxKind.ClassDeclaration:
                var c = (ClassDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(c) is INamedTypeSymbol ctype) {
                    // Info($"Found class {ctype.ContainingNamespace}.{ctype.Name}");
                    types.Add((c, model));
                }
                break;
            case SyntaxKind.StructDeclaration:
                var s = (StructDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(s) is INamedTypeSymbol stype) {
                    // Info($"Found struct {stype.ContainingNamespace}.{stype.Name}");
                    types.Add((s, model));
                }
                break;
            case SyntaxKind.InterfaceDeclaration:
                var i = (InterfaceDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(i) is INamedTypeSymbol itype) {
                    // Info($"Found interface {itype.ContainingNamespace}.{itype.Name} {itype.GetType()}");
                    types.Add((i, model));
                }
                break;
            case SyntaxKind.EnumDeclaration:
                var e = (EnumDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(e) is INamedTypeSymbol etype) {
                    // Info($"Found enum {etype.ContainingNamespace}.{etype.Name}");
                    types.Add((e, model));
                }
                break;
            case SyntaxKind.DelegateDeclaration:
                var d = (DelegateDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(d) is INamedTypeSymbol dtype) {
                    // Info($"Found delegate {dtype.ContainingNamespace}.{dtype.Name}");
                    types.Add((d, model));
                }
                break;
            case SyntaxKind.NamespaceDeclaration:
                var n = (NamespaceDeclarationSyntax)node;
                foreach (var m in n.Members) {
                    GetTypeDeclarations(m, model, compilation, types);
                }
                break;
            case SyntaxKind.CompilationUnit:
                var cu = (CompilationUnitSyntax)node;
                foreach (var m in cu.Members) {
                    GetTypeDeclarations(m, model, compilation, types);
                }
                break;
            default:
                break;
        }
    }
}
