namespace CSharpToSwift;

using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.MSBuild;

partial class Transpiler
{
    readonly string projectFilePath;
    readonly string swiftPackageName;
    readonly string swiftPackageDir;
    readonly string sourcesDir;
    readonly MSBuildWorkspace workspace = MSBuildWorkspace.Create();
    public Transpiler(string projectFilePath, string outputDir)
    {
        this.projectFilePath = Path.GetFullPath(projectFilePath);
        this.swiftPackageName = Path.GetFileNameWithoutExtension(projectFilePath);
        this.swiftPackageDir = outputDir;
        this.sourcesDir = outputDir;
    }
    static Transpiler()
    {
        Microsoft.Build.Locator.MSBuildLocator.RegisterDefaults();
        var _ = typeof(Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptions);
    }
    readonly Dictionary<string, int> errorCounts = new Dictionary<string, int> ();
    void Error(string message)
    {
        if (!errorCounts.ContainsKey(message)) {
            errorCounts[message] = 0;
            // Console.ForegroundColor = ConsoleColor.Red;
            // Console.WriteLine(message);
            // Console.ResetColor();
        }
        errorCounts[message]++; 
    }
    void Info(string message)
    {
        Console.ForegroundColor = ConsoleColor.Green;
        Console.WriteLine(message);
        Console.ResetColor();
    }
    
    public async Task TranspileAsync()
    {
        Directory.CreateDirectory(sourcesDir);
        var projectFileName = Path.GetFileName(projectFilePath);
        Info($"Loading project {projectFileName}...");
        var project = await workspace.OpenProjectAsync(projectFilePath);
        var projectLoadErrors = workspace.Diagnostics.Where(x => x.Kind == WorkspaceDiagnosticKind.Failure);
        foreach (var d in projectLoadErrors) {
            Error(d.Message);
        }
        if (projectLoadErrors.Any()) {
            Console.WriteLine($"Failed to load project {projectFileName}");
            return;
        }
        Info($"Analyzing project {project.Name}...");
        var compilation = await project.GetCompilationAsync();
        if (compilation is null) {
            Error("Failed to get compilation");
            return;
        }
        var compErrors = compilation.GetDiagnostics().Where(x => x.Severity == DiagnosticSeverity.Error).ToList();
        if (compErrors.Count > 0) {
            foreach (var d in compErrors) {
                Error(d.ToString());
            }
            return;
        }
        
        Info($"Transpiling...");
        var types = new List<(MemberDeclarationSyntax Syntax, SemanticModel Model)>();
        await GetTypeDeclarationsAsync (compilation, types);

        // var outputDir = System.IO.Path.GetDirectoryName(projectFilePath);
        TextWriter NewSwiftWriter(string swiftName) {
            var fileName = $"{swiftName}.swift";
            var filePath = System.IO.Path.Combine(sourcesDir, fileName);
            var w = new System.IO.StreamWriter(filePath);
            w.WriteLine($"// This file was generated from {Path.GetFileName(projectFileName)} by CSharpToSwift version {typeof(Transpiler).Assembly.GetName().Version}");
            return w;
        }
        using (var pw = new StreamWriter(Path.Combine(swiftPackageDir, "Package.swift"))) {
            pw.WriteLine($"// swift-tools-version: 5.6");
            pw.WriteLine();
            pw.WriteLine($"import PackageDescription");
            pw.WriteLine();
            pw.WriteLine($"let package = Package(");
            pw.WriteLine($"    name: \"{swiftPackageName}\",");
            pw.WriteLine($"    products: [");
            pw.WriteLine($"        .library(name: \"{swiftPackageName}\",");
            pw.WriteLine($"                 targets: [\"{swiftPackageName}\"])");
            pw.WriteLine($"    ],");
            pw.WriteLine($"    dependencies: [");
            pw.WriteLine($"    ],");
            pw.WriteLine($"    targets: [");
            pw.WriteLine($"        .target(name: \"{swiftPackageName}\",");
            pw.WriteLine($"                dependencies: []),");
            pw.WriteLine($"    ]");
            pw.WriteLine($")");
        }
        var swift = new StringWriter();
        swift.WriteLine("// This file was generated by CSharpToSwift");
        foreach (var (node, model) in types) {
            var symbol = (INamedTypeSymbol)model.GetDeclaredSymbol(node)!;
            var swiftName = GetSwiftTypeName(symbol);
            switch (node.Kind ()) {
                case SyntaxKind.ClassDeclaration:
                    var c = (ClassDeclarationSyntax)node;
                    using (var cw = NewSwiftWriter(swiftName)) {
                        TranspileClass(swiftName, c, symbol, model, "", cw);
                    }
                    break;
                case SyntaxKind.InterfaceDeclaration:
                    var intf = (InterfaceDeclarationSyntax)node;
                    using (var sw = NewSwiftWriter(swiftName)) {
                        TranspileInterface(swiftName, intf, symbol, model, "", sw);
                    }
                    break;
                case SyntaxKind.StructDeclaration:
                    var s = (StructDeclarationSyntax)node;
                    using (var sw = NewSwiftWriter(swiftName)) {
                        TranspileStruct(swiftName, s, symbol, model, "", sw);
                    }
                    break;
                default:
                    Error($"Unsupported type: {node.Kind()}");
                    break;
            }
        }
        // Show errors sorted by count
        var totalErrors = 0;
        foreach (var kvp in errorCounts.OrderBy(x => x.Value)) {
            var count = kvp.Value;
            totalErrors += count;
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Write($"Error:");
            Console.ResetColor();
            Console.WriteLine($" {kvp.Key} ({count}x)");
        }
        if (totalErrors > 0) {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"{totalErrors} errors");
            Console.ResetColor();
        }
        else {
            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine("OK");
            Console.ResetColor();
        }
    }

    static string GetDocs(CSharpSyntaxNode field)
    {
        var lines =
            field.GetLeadingTrivia()
            .Where(x => x.IsKind(SyntaxKind.MultiLineDocumentationCommentTrivia) || x.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia))
            .SelectMany(x => x.ToFullString().Split('\n'))
            .Select(x =>
                x
                .Replace("<summary>", "")
                .Replace("</summary>", "")
                .Replace("<b>", "**")
                .Replace("</b>", "**")
                .Replace("///", "")
                .Replace("\t", " ")
                .Trim())
            .Where(x => x.Length > 0);
        return string.Join(" ", lines);
    }

    static string GetSlotTypeModifier(MemberDeclarationSyntax member)
    {
        var isStatic = member.Modifiers.Any(x => x.IsKind(SyntaxKind.StaticKeyword));
        var isOverride = member.Modifiers.Any(x => x.IsKind(SyntaxKind.OverrideKeyword));
        var isSealed = member.Modifiers.Any(x => x.IsKind(SyntaxKind.SealedKeyword));
        var isAbstract = member.Modifiers.Any(x => x.IsKind(SyntaxKind.AbstractKeyword));
        var isVirtual = member.Modifiers.Any(x => x.IsKind(SyntaxKind.VirtualKeyword));
        var slotType = isStatic ? "static " : (isOverride ? "override " : (isAbstract ? "open " : ""));
        return slotType;
    }

    static string GetAccessLevelModifier(CSharpSyntaxNode node, SemanticModel model)
    {
        var memberSymbol = model.GetSymbolInfo(node).Symbol;
        return GetAccessLevelModifier(memberSymbol);
    }

    static string GetAccessLevelModifier(ISymbol? memberSymbol)
    {
        // access-level-modifier: private | fileprivate | internal | public | open
        if (memberSymbol is null)
            return "";
        return memberSymbol.DeclaredAccessibility switch
        {
            Accessibility.Private => "",
            Accessibility.Protected => "",
            Accessibility.Internal => "",
            Accessibility.Public => "",
            _ => "",
        };
    }

    async Task GetTypeDeclarationsAsync(Compilation compilation, List<(MemberDeclarationSyntax Syntax, SemanticModel Symbol)> types)
    {
        foreach (var s in compilation.SyntaxTrees.OfType<CSharpSyntaxTree>()) {
            // Info($"Transpiling {s.FilePath}...");
            var m = compilation.GetSemanticModel(s);
            GetTypeDeclarations(await s.GetRootAsync().ConfigureAwait(false), m, compilation, types);
        }
    }

    void GetTypeDeclarations(CSharpSyntaxNode node, SemanticModel model, Compilation compilation, List<(MemberDeclarationSyntax Syntax, SemanticModel Symbol)> types)
    {
        switch (node.Kind ()) {
            case SyntaxKind.ClassDeclaration:
                var c = (ClassDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(c) is INamedTypeSymbol ctype) {
                    // Info($"Found class {ctype.ContainingNamespace}.{ctype.Name}");
                    types.Add((c, model));
                }
                break;
            case SyntaxKind.StructDeclaration:
                var s = (StructDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(s) is INamedTypeSymbol stype) {
                    // Info($"Found struct {stype.ContainingNamespace}.{stype.Name}");
                    types.Add((s, model));
                }
                break;
            case SyntaxKind.InterfaceDeclaration:
                var i = (InterfaceDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(i) is INamedTypeSymbol itype) {
                    // Info($"Found interface {itype.ContainingNamespace}.{itype.Name} {itype.GetType()}");
                    types.Add((i, model));
                }
                break;
            case SyntaxKind.EnumDeclaration:
                var e = (EnumDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(e) is INamedTypeSymbol etype) {
                    // Info($"Found enum {etype.ContainingNamespace}.{etype.Name}");
                    types.Add((e, model));
                }
                break;
            case SyntaxKind.DelegateDeclaration:
                var d = (DelegateDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(d) is INamedTypeSymbol dtype) {
                    // Info($"Found delegate {dtype.ContainingNamespace}.{dtype.Name}");
                    types.Add((d, model));
                }
                break;
            case SyntaxKind.NamespaceDeclaration:
                var n = (NamespaceDeclarationSyntax)node;
                foreach (var m in n.Members) {
                    GetTypeDeclarations(m, model, compilation, types);
                }
                break;
            case SyntaxKind.FileScopedNamespaceDeclaration:
                var fn = (FileScopedNamespaceDeclarationSyntax)node;
                foreach (var m in fn.Members) {
                    GetTypeDeclarations(m, model, compilation, types);
                }
                break;
            case SyntaxKind.CompilationUnit:
                var cu = (CompilationUnitSyntax)node;
                foreach (var m in cu.Members) {
                    GetTypeDeclarations(m, model, compilation, types);
                }
                break;
            default:
                break;
        }
    }
}
